# CVXcanon

## Introduction
Convex optimization modeling tools like CVX, CVXPY, and Convex.Jl all translate high-level problem descriptions into low-level, canonical forms that are then passed to an backend solver. We introduce CVXCanon, a software package that factors out the common operations that all such modeling systems perform into a single library with a simple C interface. CVXCanon not only removes the need to reimplement this canonicalization process in new languages, but also provides significant performance gains on many systems.

## Layout
- **/src/** contains the source code for CVXCanon
	- **CVXcanon.(c/h)pp** implements our matrix building algorithm. This file also provides the main access point into CVXCanon's functionality, the ```build_matrix``` function.
	-  **LinOp.hpp** defines the LinOp class, our linear atoms which we traverse when building our matrix.
	- **LinOpOperations.(c/h)pp** defines functions which we can use to get coefficients corresponding to each of the LinOp. This includes 18 special cases, one for each LinOp.
    - **ProblemData.hpp** defines the structure returned by ```build_matrix```, which incldues a sparse representation of our problem matrix and our constant vector. 
    - ** CVXcanon.i ** exposes functions and data types to SWIG, allowing us to automatically generate bindings for CVXCanon in a variety of common programming languages.

- **/src/python** contains code specific to our integration of CVXCanon with CVXPY.
	- **canonInterface.py** implements code which calls our swig binding of CVXCanon, including the including the function ```get_problem_matrix```. It also defines a function to create a C++ LinOp tree from a Python LinOp tree, handling a variety of special cases related to data representation.
    - **CVXcanon.py** our Python binding, autmatically generated by SWIG.

- **/tests/** contains code to test the accuracy and performance of CVXCanon. **test_linops.py** tests a variety of problems to ensure that our basic LinOp construction and representation is correct. **huge_testman.py** CVXCanon on a variety of old EE364A problems.


## Usage with CVXPY
To install CVXCanon with CVXPY, simply run ```pip install cvxcanon```. From there, simply set the flag ```cvxpy.settings.USE_CANON = TRUE``` in your Python code:

``` python
from cvxpy import *
settings.USE_CVXCANON = True
x = Variable()
Minimize(x, [x == 0]).solve()
```
Note that on the use of CVXPY's Parameters is currently disabled in CVXCanon. One can expect a 2 - 4x  reduction in solve time on most other problems.


## Integrating with other CVX solvers
To use CVXCanon with the CVX solver of your choice one must take the following steps

1. Your language Y CVX solver must represent the problems objective and constraints each as linear atom trees at some point during the solve process. When it comes time to get the problem matrix to pass into your solver, first convert the Y into a C++ LinOp tree. This involves tree traversal, and some special cases depending on how Y represents dense and sparse matrices. You may refer to the ```build_lin_op_tree``` function in **canonInterface.py** to see an example of how this is done.

2. Pass your vector of C++ LinOps into CVXCanon's build matrix function. This will return a ```ProblemData``` structure, containing ```std::vector``` of doubles. representing the problem data. You should convert this to a data format readable. For Python, this unpacking can be done efficiently using CVXCanon's get{V/I/J} functions. For future languages, some work may be needed to do this efficiently.  

3. With these two steps implemented, you have essentially recreated **canonInterface.py** in the language of your choice. You now should be able to execute code of the form

```python 
A, b = canonInterface.get_problem_matrix(mat_cache.constraints, var_offsets)
```

and then pass ```A``` and ```b``` on to your solver as needed.

## Contact
If you have comments or concerns, please do not hesitate to contact one of us at  {piq93,jackzhu,millerjp}@stanford.edu.









